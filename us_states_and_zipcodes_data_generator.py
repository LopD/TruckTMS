# -*- coding: utf-8 -*-
'''
  Prints SQL INSERT statements used to fill the US states, US cities and zip codes for the database.
  It was initialy wirtten in google colab so it isn't documented.
'''


"""US_states_and_zipcodes_data_generator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14Y95UbvtP25h0mFlLR0-bc2gPBQt8Crm

**geolocation_usa_state** input data script
"""

states_with_abbr = """Alabama 	Ala. 	AL
Alaska 	Alaska or Alas. 	AK
Arkansas 	Ark. 	AR
Arizona 	Ariz. 	AZ
California 	Calif. 	CA
Colorado 	Colo. 	CO
Connecticut 	Conn. 	CT
Delaware 	Del. 	DE
District of Columbia 	D.C. 	DC
Florida 	Fla. 	FL
Georgia 	Ga. 	GA
Hawaii 	Hawaii 	HI
Idaho 	Idaho 	ID
Illinois 	Ill. 	IL
Indiana 	Ind. 	IN
Iowa 	Iowa 	IA
Kansas 	Kans. 	KS
Kentucky 	Ky. 	KY
Louisiana 	La. 	LA
Maine 	Maine 	ME
Maryland 	Md. 	MD
Massachusetts 	Mass. 	MA
Michigan 	Mich. 	MI
Minnesota 	Minn. 	MN
Mississippi 	Miss. 	MS
Missouri 	Mo. 	MO
Montana 	Mont. 	MT
Nebraska 	Neb. or Nebr. 	NE
Nevada 	Nev. 	NV
New Hampshire 	N.H. 	NH
New Jersey 	N.J. 	NJ
New Mexico 	N.M. 	NM
New York 	N.Y. 	NY
North Carolina 	N.C. 	NC
North Dakota 	N.D. 	ND
Ohio 	Ohio 	OH
Oklahoma 	Okla. 	OK
Oregon 	Ore. or Oreg. 	OR
Pennsylvania 	Pa. 	PA
Rhode Island 	R.I. 	RI
South Carolina 	S.C. 	SC
South Dakota 	S.D. 	SD
Tennessee 	Tenn. 	TN
Texas 	Tex. 	TX
Utah 	Utah 	UT
Vermont 	Vt. 	VT
Virginia 	Va. 	VA
Washington 	Wash. 	WA
West Virginia 	W.Va. 	WV
Wisconsin 	Wis. or Wisc. 	WI
Wyoming 	Wyo. 	WY"""

## split data into rows
states_with_abbr_tab_split = states_with_abbr.split('\t')
# print(states_with_abbr_tab_split)
names = states_with_abbr_tab_split[0::2]
# print('names=',names)

## get state abbreviations
abbr = states_with_abbr_tab_split[2::2]
abbr = [ele.split('\n') for ele in abbr]
# print('abbr=',abbr)

## add back first row
pairs = [('Alabama','AL')]
for i in range(0,len(abbr)-1):
  pairs.append((abbr[i][1].strip(),abbr[i+1][0].strip()))

## sorts in place by abbreviation in ascending order
pairs.sort(key=lambda tup: tup[1])
# print(pairs)

## print SQL script
table_name = 'geolocation_usastate'
for name,usps in pairs:
  print(f'INSERT INTO {table_name}(name,usps_abbreviation) VALUES(\'{name}\',\'{usps}\');')

"""**geolocation_city** input data script"""

import pandas as pd
## https://data.opendatasoft.com/explore/dataset/georef-united-states-of-america-zc-point%40public/table/
df = pd.read_csv('georef-united-states-of-america-zc-point@public.csv',sep=';')

## drop uneccessary columns
df = df.drop(columns=['ZCTA', 'ZCTA parent', 'Population', 'Density','Primary Official County Code', 'Primary Official County Name','County Weights', 'Official County Name', 'Official County Code','Imprecise', 'Military', 'Timezone', 'Geo Point'])

## drop rows that contain non US states in them
non_US_state_list = ['AS','PR','GU','MP', 'VI']
  ## ('American Samoa', 'AS') ('Puerto Rico', 'PR') ('Guam', 'GU') ('Northern Mariana Islands', 'MP') ('Virgin Islands', 'VI') are not US states
for non_US_state in non_US_state_list:
  df = df[df['Official USPS State Code'] != non_US_state]

## sort values
df = df.sort_values(by=['Official USPS State Code','Official USPS city name'])
# print(df.values[0:14])

# df.values[0:3,1]
table_name = 'geolocation_city' ## remove duplicates
df_distinct_city_names = pd.Series(df.values[:,1]).unique()
for city_name in df_distinct_city_names:
  a = 5
  # city_name = row[1]
  print(f'INSERT INTO {table_name}(name) VALUES (\'{city_name}\');') ## has about 17K records

"""**geolocation_city_usa_state** input data script"""

## create a copy where you'll drop all duplicate city names
df_copy = df.copy(deep=True)
df_copy = df_copy.drop(columns=['Zip Code'])

## drop all duplicate rows
df_copy = df_copy.drop_duplicates()
## now we only have for example one row that is 'Anchorage AK Alaska'
# print('------------------------')
# print(df_copy.head(14))

table_name = 'geolocation_city_usa_state'
for row_id in range(0,len(df_copy)): ##len(df_copy)
  ## (state_name, abbreviation)
  # print((df_copy.values[row_id][2],df_copy.values[row_id][1]))
  # print(pairs)
  try:
    # a = 5
    ## find the pair with the id
    ##                                    (state_name, abbreviation)
    state_id = pairs.index((df_copy.values[row_id][2],df_copy.values[row_id][1]))
    # print(state_id)
  except ValueError as e:
    print(e)
    break
  finally:
    ## print the SQL statement
    state_db_id = state_id+1 ## sequences in the database start with 1
    print(f'INSERT INTO {table_name}(city_id,usastate_id) VALUES({row_id},{state_db_id});')

"""**geolocation_zipcode** data"""

## all zip codes are unique
# print(len(df))
# print(len(pd.Series(df['Zip Code'].values).unique()))
# print(pd.Series(df['Zip Code'].values).unique()[0:5])
table_name = 'geolocation_zipcode'
for zip_code in pd.Series(df['Zip Code'].values).unique():
  if (len(str(zip_code)) > 5):
    print('zip_code len is > 5:',zip_code)
    break
  print(f'INSERT INTO {table_name}(code) VALUES (\'{zip_code}\');')

"""**geolocation_cityzipcode**"""

import numpy as np

## all zip codes are unique and so are all the combinations of cities and zip codes
# print(df.head(5))
# print(df_distinct_city_names.index())
# print(len(pd.Series(df['Zip Code'].values).unique()))
# print(pd.Series(df['Zip Code'].values).unique()[0:5])
import os
table_name = 'geolocation_cityzipcode'
with open('blank.txt','w') as out:

  for zip_code,city_name,abbr,state in df.values:
    if (len(str(zip_code)) > 5):
      print('zip_code len is > 5:',zip_code)
      break

    ## find the appropriate city
    try:
      # print(type(df_distinct_city_names))
      # print(df_distinct_city_names.shape)
      # print(df_distinct_city_names.flatten().shape)
      city_id = np.where(df_distinct_city_names == city_name)
      city_db_id = city_id[0][0] + 1 ## database sequences start from 1, city_id[0][0] since it's a ndarray
      # print(city_name,city_id,city_id[0], city_id[0][0])
      out.write(f'INSERT INTO {table_name}(city_id,zipcode_id) VALUES ({city_db_id},\'{zip_code}\');\n')

    except ValueError as e:
      print(e)
      break